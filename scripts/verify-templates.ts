#!/usr/bin/env node

/**
 * Template Verification System for 123LegalDoc
 *
 * This script ensures all legal document templates meet quality standards,
 * enforces bilingual parity (variables, sections, metadata), and prevents duplicate content issues.
 *
 * Run: npm run verify-templates
 * - Checks EN/ES template parity before generating the report.
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import chalk from 'chalk';
import { DOCUMENT_METADATA } from '../src/lib/documents/manifest.generated';

import {
  findTranslationParityIssues,
  type BilingualTemplateSummary,
  type MetadataIndex,
} from './verify-templates-parity';


interface TemplateValidationResult {
  path: string;
  isValid: boolean;
  errors: string[];
  warnings: string[];
  contentHash: string;
  documentType: string;
  language: string;
  variables: string[];
  sectionHeadings: string[];
  numberedSections: string[];
  variableCount: number;
  sectionCount: number;
  wordCount: number;
}

interface ValidationRules {
  minWordCount: number;
  maxWordCount: number;
  requiredSections: string[];
  requiredVariables: string[];
  prohibitedContent: string[];
  documentTypePatterns: Record<string, RegExp>;
}

interface TemplateVerifierOptions {
  reportOnly?: boolean;
}

class TemplateVerifier {
  private templateDir: string;
  private validationResults: TemplateValidationResult[] = [];
  private duplicateHashes: Map<string, string[]> = new Map();
  private metadataIndex: MetadataIndex;
  private readonly reportOnly: boolean;

  // Validation rules for all templates
  private globalRules: ValidationRules = {
    minWordCount: 500, // Minimum words for a valid legal document
    maxWordCount: 10000, // Maximum reasonable length
    requiredSections: [
      '## 1.', // Must have numbered sections
      '## Signatures', // Must have signature section
      'IMPORTANT LEGAL NOTICE', // Must have legal disclaimer
    ],
    requiredVariables: [
      '{{', // Must contain Handlebars variables
      '{{agreement_date}}', // Common to most documents
    ],
    prohibitedContent: [
      'Vehicle Bill of Sale', // The problematic duplicate content
      '_Template generated by 123 LegalDoc_', // Old footer format
      'Replace bracketed fields with actual data', // Old instruction format
    ],
    documentTypePatterns: {
      'bill-of-sale-vehicle': /Vehicle Bill of Sale|VIN|Odometer/i,
      'promissory-note': /Promissory Note|Principal Amount|Interest Rate/i,
      'lease-agreement': /Lease Agreement|Landlord|Tenant|Rent/i,
      nda: /Non-Disclosure Agreement|Confidential Information/i,
      'power-of-attorney': /Power of Attorney|Principal|Agent|Authority/i,
      'child-medical-consent':
        /Medical Consent|Child|Caregiver|Medical Treatment/i,
      'living-trust': /Living Trust|Trustee|Beneficiary|Trust Property/i,
      'service-agreement':
        /Service Agreement|Services|Compensation|Deliverables/i,
      'employment-offer-letter': /Employment Offer|Position|Salary|Benefits/i,
      'independent-contractor-agreement':
        /Independent Contractor|Services|Payment Terms/i,
      'last-will-testament': /Last Will|Executor|Beneficiaries|Estate/i,
      'eviction-notice': /Eviction Notice|Tenant|Premises|Violation/i,
      'operating-agreement':
        /Operating Agreement|LLC|Members|Capital Contributions/i,
      'commercial-lease-agreement':
        /Commercial Lease|Lessee|Lessor|Commercial Property/i,
      'employment-termination-letter':
        /Termination|Employment|Last Day|Final Pay/i,
      'healthcare-power-of-attorney':
        /Healthcare|Medical Decisions|Healthcare Agent/i,
      'quitclaim-deed': /Quitclaim Deed|Grantor|Grantee|Property Transfer/i,
      'prenuptial-agreement':
        /Prenuptial Agreement|Future Spouse|Assets|Marriage/i,
      'affidavit-general': /Affidavit|Affiant|Sworn|Notary/i,
      'articles-of-incorporation-biz':
        /Articles of Incorporation|Corporation|Shares|Directors/i,
      'child-custody-agreement':
        /Child Custody|Visitation|Parenting Time|Support/i,
      'demand-letter-payment': /Demand for Payment|Debt|Amount Due|Collection/i,
      'divorce-settlement-agreement':
        /Divorce Settlement|Petitioner|Respondent|Property Division/i,
      invoice: /Invoice|Bill To|Payment Terms|Amount Due/i,
      'living-will':
        /Living Will|Healthcare Directive|Life-Sustaining Treatment/i,
      'non-compete-agreement':
        /Non-Compete|Restricted Territory|Competitive Business/i,
      'partnership-agreement':
        /Partnership Agreement|Partners|Capital Contributions|Profit Sharing/i,
    },
  };

  // Document-specific validation rules
  private documentRules: Record<string, Partial<ValidationRules>> = {
    'advance-directive': {
      requiredVariables: [
        '{{witness_one_name}}',
        '{{witness_one_signature_date}}',
        '{{witness_two_name}}',
        '{{witness_two_signature_date}}',
        '{{notary_state}}',
        '{{notary_county}}',
        '{{notary_date}}',
        '{{notary_commission_expiration}}',
      ],
    },
    'bill-of-sale-vehicle': {
      requiredSections: [
        'Vehicle Description',
        'Purchase Price',
        'Condition of Vehicle',
      ],
      requiredVariables: [
        '{{vin}}',
        '{{make}}',
        '{{model}}',
        '{{year}}',
        '{{price}}',
      ],
    },
    'promissory-note': {
      requiredSections: [
        'Principal Amount',
        'Interest Rate',
        'Payment Terms',
        'Default',
      ],
      requiredVariables: [
        '{{principal_amount}}',
        '{{interest_rate}}',
        '{{payment_schedule}}',
      ],
    },
    'lease-agreement': {
      requiredSections: [
        'Property Description',
        'Term of Lease',
        'Rent',
        'Security Deposit',
      ],
      requiredVariables: [
        '{{monthly_rent}}',
        '{{lease_start_date}}',
        '{{lease_end_date}}',
      ],
    },
    'living-will': {
      requiredSections: [
        'Healthcare Directives',
        'Life-Sustaining Treatment',
        'Healthcare Agent',
      ],
      requiredVariables: [
        '{{declarant_name}}',
        '{{state}}',
        '{{healthcare_agent}}',
      ],
    },
    'child-custody-agreement': {
      requiredSections: [
        'Custody Arrangements',
        'Visitation Schedule',
        'Child Support',
      ],
      requiredVariables: [
        '{{parent_1_name}}',
        '{{parent_2_name}}',
        '{{child_1_name}}',
      ],
    },
  };

  constructor(templateDir: string, options: TemplateVerifierOptions = {}) {
    this.templateDir = templateDir;
    this.metadataIndex = DOCUMENT_METADATA;
    this.reportOnly = options.reportOnly ?? false;
  }

  /**
   * Main verification process
   */
  async verifyAllTemplates(): Promise<boolean> {
    console.log(
      chalk.blue.bold('\n[verify] Starting Template Verification System\n'),
    );

    const languages = ['en', 'es'];
    let allValid = true;

    for (const lang of languages) {
      const langDir = path.join(this.templateDir, lang);
      if (!fs.existsSync(langDir)) continue;

      console.log(
        chalk.yellow(`\nVerifying ${lang.toUpperCase()} templates...`),
      );

      const files = fs.readdirSync(langDir).filter((f) => f.endsWith('.md'));

      for (const file of files) {
        const filePath = path.join(langDir, file);
        const result = await this.verifyTemplate(filePath);
        this.validationResults.push(result);

        if (!result.isValid) {
          allValid = false;
          this.reportErrors(result);
        } else {
          console.log(chalk.green(`[OK] ${file}`));
        }

        // Track content hashes for duplicate detection
        if (!this.duplicateHashes.has(result.contentHash)) {
          this.duplicateHashes.set(result.contentHash, []);
        }
        this.duplicateHashes.get(result.contentHash)!.push(result.path);
      }
    }

    this.checkLanguageParity();

    // Check for duplicates
    this.checkForDuplicates();

    const finalValidity = this.validationResults.every((r) => r.isValid);

    // Generate report
    this.generateReport();

    return finalValidity;
  }

  private checkLanguageParity(): void {
    const summaries: BilingualTemplateSummary[] = this.validationResults.map((result) => ({
      documentType: result.documentType,
      language: result.language,
      variables: result.variables,
      sectionHeadings: result.sectionHeadings,
      numberedSections: result.numberedSections,
    }));

    const issues = findTranslationParityIssues(summaries, this.metadataIndex);

    for (const issue of issues) {
      let attached = false;

      for (const language of issue.affectedLanguages) {
        const target = this.validationResults.find(
          (r) =>
            r.documentType === issue.documentType && r.language === language,
        );

        if (target) {
          this.raiseParityError(target, issue.message);
          attached = true;
        }
      }

      if (!attached) {
        const fallback = this.validationResults.find(
          (r) => r.documentType === issue.documentType,
        );

        if (fallback) {
          this.raiseParityError(fallback, issue.message);
        } else {
          console.log(chalk.red(`[PARITY] ${issue.documentType}: ${issue.message}`));
        }
      }
    }
  }

  /**
   * Verify a single template
   */
  private async verifyTemplate(
    filePath: string,
  ): Promise<TemplateValidationResult> {
    const content = fs.readFileSync(filePath, 'utf-8');
    const fileName = path.basename(filePath, '.md');
    const language = path.basename(path.dirname(filePath));
    const contentHash = crypto.createHash('md5').update(content).digest('hex');
    const variableTokens = Array.from(
      content.matchAll(/\{\{\s*([#\/>]?)\s*([a-zA-Z0-9_.-]+)[^}]*\}\}/g),
    );
    const variableNames = variableTokens
      .map(([, prefix, name]) => ({ prefix, name }))
      .filter(
        ({ prefix, name }) =>
          Boolean(name) && !['#', '/', '>'].includes(prefix) && name !== 'else',
      )
      .map(({ name }) => name.trim());
    const variables = Array.from(new Set(variableNames)).sort();

    const lines = content.split(/\r?\n/).map((line) => line.trim());
    const sectionHeadings = lines
      .filter((line) => line.startsWith('## '))
      .map((line) => line.replace(/^##\s+/, '').trim());
    const numberedSections = sectionHeadings
      .map((heading) => {
        const match = heading.match(/^(\d+(?:\.\d+)*)/);
        return match ? match[1] : null;
      })
      .filter((value): value is string => Boolean(value));
    const wordCount = content.split(/\s+/).length;

    const result: TemplateValidationResult = {
      path: filePath,
      isValid: true,
      errors: [],
      warnings: [],
      contentHash,
      documentType: fileName,
      language,
      variables,
      sectionHeadings,
      numberedSections,
      variableCount: variableNames.length,
      sectionCount: numberedSections.length,
      wordCount,
    };

    // Apply global rules
    this.applyGlobalRules(content, result);

    // Apply document-specific rules
    this.applyDocumentSpecificRules(fileName, content, result);

    // Check document type consistency
    this.checkDocumentTypeConsistency(fileName, content, result);

    // Validate template structure
    this.validateTemplateStructure(content, result);

    result.isValid = result.errors.length === 0;

    return result;
  }

  /**
   * Apply global validation rules
   */
  private applyGlobalRules(
    content: string,
    result: TemplateValidationResult,
  ): void {
    const rules = this.globalRules;

    // Check word count
    if (result.wordCount < rules.minWordCount) {
      result.errors.push(
        `Document too short: ${result.wordCount} words (minimum: ${rules.minWordCount})`,
      );
    }
    if (result.wordCount > rules.maxWordCount) {
      result.warnings.push(
        `Document very long: ${result.wordCount} words (typical max: ${rules.maxWordCount})`,
      );
    }

    // Check required sections
    for (const section of rules.requiredSections) {
      if (!content.includes(section)) {
        result.errors.push(`Missing required section: "${section}"`);
      }
    }

    // Check for variables
    if (result.variableCount < 5) {
      result.errors.push(
        `Too few variables: ${result.variableCount} (minimum: 5)`,
      );
    }

    // Check for prohibited content
    for (const prohibited of rules.prohibitedContent) {
      if (content.includes(prohibited)) {
        result.errors.push(`Contains prohibited content: "${prohibited}"`);
      }
    }
  }

  /**
   * Apply document-specific validation rules
   */
  private applyDocumentSpecificRules(
    fileName: string,
    content: string,
    result: TemplateValidationResult,
  ): void {
    const specificRules = this.documentRules[fileName];
    if (!specificRules) return;

    // Check required sections for this document type
    if (specificRules.requiredSections) {
      for (const section of specificRules.requiredSections) {
        if (!content.toLowerCase().includes(section.toLowerCase())) {
          result.errors.push(`Missing document-specific section: "${section}"`);
        }
      }
    }

    // Check required variables for this document type
    if (specificRules.requiredVariables) {
      for (const variable of specificRules.requiredVariables) {
        if (!content.includes(variable)) {
          result.errors.push(`Missing required variable: "${variable}"`);
        }
      }
    }
  }

  /**
   * Check if document content matches its filename
   */
  private checkDocumentTypeConsistency(
    fileName: string,
    content: string,
    result: TemplateValidationResult,
  ): void {
    const pattern = this.globalRules.documentTypePatterns[fileName];
    if (!pattern) {
      result.warnings.push(
        `No content pattern defined for document type: ${fileName}`,
      );
      return;
    }

    if (!pattern.test(content)) {
      result.errors.push(
        `Content does not match expected document type: ${fileName}`,
      );

      // Check if it matches a different document type
      for (const [docType, docPattern] of Object.entries(
        this.globalRules.documentTypePatterns,
      )) {
        if (docType !== fileName && docPattern.test(content)) {
          result.errors.push(
            `Content appears to be a ${docType} instead of ${fileName}`,
          );
          break;
        }
      }
    }
  }

  /**
   * Validate template structure
   */
  private validateTemplateStructure(
    content: string,
    result: TemplateValidationResult,
  ): void {
    const lines = content.split(/\r?\n/);

    // Check for proper header
    if (!lines[0].startsWith('# ')) {
      result.errors.push('Missing main header (# Title)');
    }

    // Check for proper section numbering
    const sections = lines.filter((line) => line.match(/^##\s+\d+\./));
    const expectedNumbers = Array.from(
      { length: sections.length },
      (_, i) => i + 1,
    );
    const actualNumbers = sections.map((s) => parseInt(s.match(/\d+/)![0]));

    if (JSON.stringify(actualNumbers) !== JSON.stringify(expectedNumbers)) {
      result.errors.push('Section numbering is not sequential');
    }

    // Check for balanced Handlebars conditions
    const ifCount = (content.match(/\{\{#if/g) || []).length;
    const endIfCount = (content.match(/\{\{\/if/g) || []).length;
    if (ifCount !== endIfCount) {
      result.errors.push(
        `Unbalanced Handlebars conditions: ${ifCount} #if vs ${endIfCount} /if`,
      );
    }

    // Check for proper markdown formatting
    if (content.includes('**_') || content.includes('_**')) {
      result.warnings.push('Inconsistent markdown formatting detected');
    }
  }

  /**
   * Check for duplicate content across templates
   */
  private checkForDuplicates(): void {
    console.log(chalk.yellow('\n[scan] Checking for duplicate content...'));

    for (const [hash, files] of this.duplicateHashes.entries()) {
      if (files.length > 1) {
        console.log(chalk.red('\n[FAIL] DUPLICATE CONTENT DETECTED:'));
        console.log(chalk.red(`The following files have identical content:`));
        files.forEach((file) => console.log(chalk.red(`  - ${file}`)));

        // Mark all duplicates as invalid
        this.validationResults
          .filter((r) => files.includes(r.path))
          .forEach((r) => {
            r.isValid = false;
            r.errors.push(
              'DUPLICATE CONTENT: This file has identical content to other templates',
            );
          });
      }
    }
  }

  private raiseParityError(
    result: TemplateValidationResult,
    message: string,
  ): void {
    if (!result.errors.includes(message)) {
      const wasValid = result.isValid;
      result.errors.push(message);
      result.isValid = false;
      if (wasValid) {
        this.reportErrors(result);
      }
    }
  }

  /**
   * Report errors for a template
   */
  private reportErrors(result: TemplateValidationResult): void {
    console.log(chalk.red(`\n[FAIL] ${path.basename(result.path)}`));

    if (result.errors.length > 0) {
      console.log(chalk.red('  Errors:'));
      result.errors.forEach((error) =>
        console.log(chalk.red(`    - ${error}`)),
      );
    }

    if (result.warnings.length > 0) {
      console.log(chalk.yellow('  Warnings:'));
      result.warnings.forEach((warning) =>
        console.log(chalk.yellow(`    - ${warning}`)),
      );
    }

    console.log(
      chalk.gray(
        `  Stats: ${result.wordCount} words, ${result.variableCount} variables, ${result.sectionCount} sections`,
      ),
    );
  }

  /**
   * Generate verification report
   */
  private generateReport(): void {
    const totalTemplates = this.validationResults.length;
    const validTemplates = this.validationResults.filter(
      (r) => r.isValid,
    ).length;
    const invalidTemplates = totalTemplates - validTemplates;
    const totalErrors = this.validationResults.reduce(
      (sum, r) => sum + r.errors.length,
      0,
    );
    const totalWarnings = this.validationResults.reduce(
      (sum, r) => sum + r.warnings.length,
      0,
    );

    console.log(chalk.blue.bold('\n[Report] Verification Report\n'));
    console.log(`Total Templates: ${totalTemplates}`);
    console.log(`Valid Templates: ${chalk.green(validTemplates)}`);
    console.log(`Invalid Templates: ${chalk.red(invalidTemplates)}`);
    console.log(`Total Errors: ${chalk.red(totalErrors)}`);
    console.log(`Total Warnings: ${chalk.yellow(totalWarnings)}`);

    // Save detailed report
    const reportPath = path.join(
      this.templateDir,
      '..',
      '..',
      'template-verification-report.json',
    );
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalTemplates,
        validTemplates,
        invalidTemplates,
        totalErrors,
        totalWarnings,
      },
      results: this.validationResults,
    };

    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    console.log(chalk.gray(`\nDetailed report saved to: ${reportPath}`));

    if (invalidTemplates > 0) {
      console.log(
        chalk.red.bold('\n[FAIL] VERIFICATION FAILED: Fix the errors above and run verification again.'),
      );
      if (!this.reportOnly) {
        process.exit(1);
      } else {
        console.log(
          chalk.gray('[report-only] Exit code suppressed for diagnostic run.'),
        );
      }
    } else {
      console.log(
        chalk.green.bold('\n[OK] ALL TEMPLATES VERIFIED SUCCESSFULLY!'),
      );
    }
  }
}

// Run verification
async function main() {
  const args = process.argv.slice(2);
  const reportOnly = args.includes('--report-only');

  const templateDir = path.join(__dirname, '..', 'public', 'templates');
  const verifier = new TemplateVerifier(templateDir, { reportOnly });

  try {
    const isValid = await verifier.verifyAllTemplates();
    if (!isValid && !reportOnly) {
      process.exit(1);
    }
  } catch (error) {
    console.error(chalk.red('Verification failed with error:'), error);
    if (!reportOnly) {
      process.exit(1);
    }
  }
}

// Execute if run directly
if (require.main === module) {
  main();
}

export { TemplateVerifier };
export { findTranslationParityIssues } from './verify-templates-parity';
